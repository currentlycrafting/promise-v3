<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reframe — Promise</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Plus+Jakarta+Sans:wght@400;500;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="css/base.css">
<link rel="stylesheet" href="css/nav.css">
<link rel="stylesheet" href="css/sections.css">
<style>
  .reframe {
    max-width: 600px;
    margin: 0 auto;
    padding: 56px 24px 64px;
  }
  .reframe h1 { font-size: 32px; margin-bottom: 4px; }
  .reframe .sub { color: var(--muted); font-size: 14px; margin-bottom: 32px; }

  .missed-card {
    background: #fff5f5;
    border: 1px solid #fecaca;
    border-radius: 10px;
    padding: 20px 24px;
    margin-bottom: 32px;
  }
  .missed-card h3 { font-size: 17px; margin-bottom: 4px; }
  .missed-card p { font-size: 13px; color: var(--muted); }
  .missed-label {
    display: inline-block;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #d44;
    margin-bottom: 8px;
  }

  .form-group {
    margin-bottom: 24px;
  }
  .form-group label {
    display: block;
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--ink);
  }
  .form-group input[type="text"],
  .form-group select {
    width: 100%;
    font-family: 'Plus Jakarta Sans', sans-serif;
    font-size: 14px;
    padding: 10px 14px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--card);
    color: var(--ink);
    outline: none;
    transition: border-color 0.2s;
  }
  .form-group input:focus,
  .form-group select:focus {
    border-color: var(--accent);
  }

  .solutions-wrap {
    display: none;
    margin-top: 32px;
  }
  .solutions-wrap.visible { display: block; }
  .solutions-wrap h2 { font-size: 22px; margin-bottom: 16px; }

  .solution {
    background: var(--card);
    border: 2px solid var(--border);
    border-radius: 10px;
    padding: 16px 20px;
    margin-bottom: 12px;
    cursor: pointer;
    transition: border-color 0.2s;
  }
  .solution:hover { border-color: var(--accent); }
  .solution.selected { border-color: var(--accent); background: #fff7f5; }
  .solution .sol-label {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--accent);
    margin-bottom: 4px;
  }
  .solution .sol-text {
    font-size: 14px;
    color: var(--ink);
    line-height: 1.5;
  }

  .actions {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-top: 24px;
  }
  .actions .btn { padding: 10px 28px; font-size: 14px; }
  .actions .back {
    font-size: 14px;
    color: var(--muted);
    text-decoration: none;
  }

  #status {
    margin-top: 16px;
    font-size: 13px;
    color: var(--muted);
    min-height: 20px;
  }
  #status.error { color: #d44; }
  #status.success { color: #2a9d5c; }
</style>
</head>
<body>

<nav id="nav">
  <a class="wordmark" href="index.html">Promise<span class="dot">.</span></a>
  <div class="nav-r">
    <a href="dashboard.html">Dashboard</a>
    <a href="promise.html" class="btn">Make a Promise</a>
  </div>
</nav>

<main>
  <section class="reframe">
    <h1>Time to reframe<span class="dot">.</span></h1>
    <p class="sub">Missing a deadline isn't the end. Let's find a better path forward.</p>

    <div class="missed-card" id="missedCard">
      <span class="missed-label">Missed</span>
      <h3 id="missedName">Loading...</h3>
      <p id="missedContent"></p>
    </div>

    <!-- Step 1: Reason + Category -->
    <div id="step1">
      <div class="form-group">
        <label for="reason">Why did you miss this promise?</label>
        <input type="text" id="reason" placeholder="e.g. I ran out of time this week" required>
      </div>
      <div class="form-group">
        <label for="category">What category best describes it?</label>
        <select id="category">
          <option value="TIME_CONSTRAINT">Time constraint</option>
          <option value="RESOURCE_LIMITATION">Resource limitation</option>
          <option value="EXTERNAL_FACTORS">External factors</option>
          <option value="MOTIVATION_LOSS">Motivation loss</option>
          <option value="UNCLEAR_GOALS">Unclear goals</option>
          <option value="OVERCOMMITMENT">Overcommitment</option>
          <option value="SKILL_GAP">Skill gap</option>
        </select>
      </div>
      <div class="actions">
        <button class="btn" id="generateBtn">Generate Solutions</button>
        <a href="dashboard.html" class="back">Back</a>
      </div>
      <div id="status"></div>
    </div>

    <!-- Step 2: Pick a solution -->
    <div class="solutions-wrap" id="step2">
      <h2>Pick a path forward<span class="dot">.</span></h2>
      <div id="solutionsList"></div>
      <div class="actions">
        <button class="btn" id="applyBtn" disabled>Apply Solution</button>
        <button class="back" id="backBtn" style="border:none;background:none;cursor:pointer;">Try again</button>
      </div>
      <div id="status2"></div>
    </div>
  </section>
</main>

<footer>
  <span>&copy; 2026 Promise.</span>
  <div><a href="#">Privacy</a><a href="#">Terms</a></div>
</footer>

<script type="module">
  let llm = null;
  try {
    llm = await import('./frontend/llm.js');
  } catch (e) {
    console.warn('LLM module not available:', e.message);
  }

  const params = new URLSearchParams(window.location.search);
  const promiseId = params.get('id');
  let missedPromise = null;
  let selectedSolution = null;
  let solutionsRaw = '';

  const statusEl = document.getElementById('status');
  const status2El = document.getElementById('status2');

  function setStatus(el, msg, type) {
    el.textContent = msg;
    el.className = type || '';
  }

  window.addEventListener('scroll', () => {
    document.getElementById('nav').classList.toggle('scrolled', scrollY > 10);
  }, { passive: true });

  // Load missed promise
  async function loadMissed() {
    try {
      const res = await fetch('/api/promises');
      const data = await res.json();
      if (data.missed) {
        missedPromise = data.missed;
        document.getElementById('missedName').textContent = data.missed.name;
        document.getElementById('missedContent').textContent = data.missed.content;
      } else {
        window.location.href = 'dashboard.html';
      }
    } catch {
      setStatus(statusEl, 'Could not load promise. Is the backend running?', 'error');
    }
  }

  // Step 1: Generate solutions
  document.getElementById('generateBtn').addEventListener('click', async () => {
    const reason = document.getElementById('reason').value.trim();
    const category = document.getElementById('category').value;
    if (!reason) {
      setStatus(statusEl, 'Please explain why you missed this promise.', 'error');
      return;
    }

    const btn = document.getElementById('generateBtn');
    btn.disabled = true;

    if (llm) {
      try {
        setStatus(statusEl, 'Loading AI model...');
        await llm.initLLM('/models/model.gguf', 'promise-model');

        setStatus(statusEl, 'Generating solutions...');
        solutionsRaw = await llm.refinePromise(missedPromise.content, reason, category);

        showSolutions(solutionsRaw);
        setStatus(statusEl, '');
      } catch (err) {
        console.warn('LLM failed:', err.message);
        setStatus(statusEl, 'AI unavailable. Showing default solutions.', 'error');
        showFallbackSolutions();
      }
    } else {
      showFallbackSolutions();
    }
    btn.disabled = false;
  });

  function showFallbackSolutions() {
    // Strip leading "I promise I will" from content to avoid duplication
    const raw = missedPromise.content;
    const core = raw.replace(/^I promise I will\s*/i, '');
    solutionsRaw = `1. Conservative Solution:\n- Revised promise: I promise I will ${core}, but with a smaller scope\n\n2. Moderate Solution:\n- Revised promise: I promise I will ${core}, with adjusted expectations\n\n3. Progressive Solution:\n- Revised promise: I promise I will ${core}, and push even further`;
    showSolutions(solutionsRaw);
  }

  function showSolutions(text) {
    // Parse solutions from LLM text — handles markdown headers, bullet points, etc.
    const solutions = [];
    const labels = ['Conservative', 'Moderate', 'Progressive'];

    // Split by numbered items or markdown headers containing solution labels
    const parts = text.split(/(?:\d+\.\s*|#{1,3}\s*)(?:conservative|moderate|progressive)\s*solution\s*:?/i);

    for (let i = 1; i < parts.length && solutions.length < 3; i++) {
      const chunk = parts[i].trim();
      // Look for "Revised promise:" or "I promise I will" lines
      const promiseMatch = chunk.match(/(?:[Rr]evised promise:\s*|[-*]\s*)?(I promise I will[^\n]+)/);
      const text_ = promiseMatch ? promiseMatch[1].trim() : chunk.split('\n').filter(l => l.trim() && !l.startsWith('#') && !l.startsWith('---'))[0]?.replace(/^[-*]\s*/, '').trim() || chunk.trim();
      if (text_) {
        solutions.push({
          label: labels[solutions.length] || `Option ${solutions.length + 1}`,
          text: text_
        });
      }
    }

    if (!solutions.length) {
      // Fallback: grab any "I promise I will" lines
      const promises = text.match(/I promise I will[^\n]+/gi) || [];
      for (let i = 0; i < Math.min(promises.length, 3); i++) {
        solutions.push({ label: labels[i], text: promises[i].trim() });
      }
    }

    if (!solutions.length) {
      // Last resort: non-empty, non-header lines
      const lines = text.split('\n').filter(l => l.trim() && !l.startsWith('#'));
      for (let i = 0; i < Math.min(lines.length, 3); i++) {
        solutions.push({ label: labels[i], text: lines[i].replace(/^[-*\d.]\s*/, '').trim() });
      }
    }

    const listEl = document.getElementById('solutionsList');
    listEl.innerHTML = solutions.map((s, i) => `
      <div class="solution" data-idx="${i}" data-label="${s.label}" data-text="${esc(s.text)}">
        <div class="sol-label">${s.label} Solution</div>
        <div class="sol-text">${esc(s.text)}</div>
      </div>
    `).join('');

    // Click to select
    listEl.querySelectorAll('.solution').forEach(el => {
      el.addEventListener('click', () => {
        listEl.querySelectorAll('.solution').forEach(s => s.classList.remove('selected'));
        el.classList.add('selected');
        selectedSolution = { label: el.dataset.label, text: el.dataset.text };
        document.getElementById('applyBtn').disabled = false;
      });
    });

    document.getElementById('step1').style.display = 'none';
    document.getElementById('step2').classList.add('visible');
  }

  function esc(s) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  // Step 2: Apply solution
  document.getElementById('applyBtn').addEventListener('click', async () => {
    if (!selectedSolution) return;

    const btn = document.getElementById('applyBtn');
    btn.disabled = true;

    const reason = document.getElementById('reason').value.trim();
    const category = document.getElementById('category').value;
    let name = missedPromise.name + ' (revised)';
    let content = selectedSolution.text;
    let deadline = '24h';

    // Try using LLM to generate structured fields
    if (llm) {
      try {
        setStatus(status2El, 'Generating updated promise...');
        const updated = await llm.generateUpdatedPromise(
          missedPromise.content, reason, category, selectedSolution.label
        );
        const parsed = llm.parseUpdate(updated);
        if (parsed.name) name = parsed.name;
        if (parsed.promise) content = parsed.promise;
        if (parsed.deadline) deadline = parsed.deadline;
      } catch (err) {
        console.warn('LLM update failed, using defaults:', err.message);
      }
    }

    // POST to backend
    try {
      setStatus(status2El, 'Saving reframed promise...');
      const body = new FormData();
      body.append('name', name);
      body.append('content', content);
      body.append('deadline', deadline);

      const id = missedPromise.id;
      const res = await fetch(`/api/reframe/${id}/apply`, { method: 'POST', body });
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.detail || 'Failed to apply');
      }

      setStatus(status2El, 'Promise reframed!', 'success');
      setTimeout(() => { window.location.href = 'dashboard.html'; }, 800);
    } catch (err) {
      setStatus(status2El, err.message, 'error');
      btn.disabled = false;
    }
  });

  // Back button
  document.getElementById('backBtn').addEventListener('click', () => {
    document.getElementById('step2').classList.remove('visible');
    document.getElementById('step1').style.display = '';
    selectedSolution = null;
  });

  loadMissed();
</script>
</body>
</html>
